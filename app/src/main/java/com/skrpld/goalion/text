почему пропала сортировака? цели должны динамически сортироваться между собой по статусу и по приоритету, так же задачи внутри целей тоже должны сортироваться между собой по статусу и по приоритету. Доделай функционал динамического перетаскивания целей и задач внутри целей с учётом сортировки.
Пиши изменённые файлы полностью

package com.skrpld.goalion.ui.screens.main

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.skrpld.goalion.data.database.AppDao
import com.skrpld.goalion.data.database.TaskStatus
import com.skrpld.goalion.data.models.*
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.util.Collections

class MainViewModel(private val dao: AppDao) : ViewModel() {

    private val _selectedActionItem = MutableStateFlow<ActionTarget?>(null)
    val selectedActionItem = _selectedActionItem.asStateFlow()

    private val _editingId = MutableStateFlow<String?>(null)
    val editingId = _editingId.asStateFlow()

    private val _selectedTaskForDetails = MutableStateFlow<Task?>(null)
    val selectedTaskForDetails = _selectedTaskForDetails.asStateFlow()

    private val _expandedGoalIds = MutableStateFlow<Set<Int>>(emptySet())

    private var prioritySaveJob: Job? = null

    private val profileFlow = flow {
        var profile = dao.getAnyProfile()
        if (profile == null) {
            val newId = dao.upsertProfile(Profile(name = "Default"))
            profile = Profile(id = newId.toInt(), name = "Default")
        }
        emit(profile)
    }

    @OptIn(ExperimentalCoroutinesApi::class)
    val uiState: StateFlow<MainUiState> = profileFlow.flatMapLatest { profile ->
        combine(
            dao.getGoalsWithTasksList(profile.id),
            _expandedGoalIds
        ) { goalsWithTasks, expandedIds ->
            if (goalsWithTasks.isEmpty()) {
                MainUiState.Empty(profile.id)
            } else {
                val sortedGoals = goalsWithTasks.sortedBy { it.goal.orderIndex }
                val flatList = mutableListOf<GoalListItem>()

                sortedGoals.forEach { item ->
                    val isExpanded = expandedIds.contains(item.goal.id)
                    flatList.add(GoalListItem.GoalHeader(item.goal, isExpanded))
                    if (isExpanded) {
                        val sortedTasks = item.tasks.sortedBy { it.orderIndex }
                        flatList.addAll(sortedTasks.map { GoalListItem.TaskItem(it) })
                    }
                }
                MainUiState.Success(flatList, profile.id, sortedGoals)
            }
        }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), MainUiState.Loading)

    sealed class MainUiState {
        object Loading : MainUiState()
        data class Success(
            val items: List<GoalListItem>,
            val profileId: Int,
            val rawData: List<GoalWithTasks>
        ) : MainUiState()
        data class Empty(val profileId: Int) : MainUiState()
    }

    // --- Sorting and moving ---

    fun moveGoal(fromIndex: Int, toIndex: Int) {
        val state = uiState.value as? MainUiState.Success ?: return
        val list = state.rawData.map { it.goal }.toMutableList()
        if (fromIndex !in list.indices || toIndex !in list.indices) return

        Collections.swap(list, fromIndex, toIndex)

        viewModelScope.launch {
            list.forEachIndexed { index, goal ->
                dao.upsertGoal(goal.copy(orderIndex = index))
            }
        }
    }

    fun moveTask(goalId: Int, fromIndex: Int, toIndex: Int) {
        val state = uiState.value as? MainUiState.Success ?: return
        val goalWithTasks = state.rawData.find { it.goal.id == goalId } ?: return
        val tasks = goalWithTasks.tasks.sortedBy { it.orderIndex }.toMutableList()

        if (fromIndex !in tasks.indices || toIndex !in tasks.indices) return
        Collections.swap(tasks, fromIndex, toIndex)

        viewModelScope.launch {
            tasks.forEachIndexed { index, task ->
                dao.upsertTask(task.copy(orderIndex = index))
            }
        }
    }

    // --- Actions ---

    fun addGoal(profileId: Int) {
        viewModelScope.launch {
            val state = uiState.value as? MainUiState.Success
            val maxOrder = state?.rawData?.maxOfOrNull { it.goal.orderIndex } ?: -1
            val id = dao.upsertGoal(Goal(title = "", profileId = profileId, orderIndex = maxOrder + 1)).toInt()
            startEditing(id, isGoal = true)
        }
    }

    fun addTask(goalId: Int) {
        viewModelScope.launch {
            val state = uiState.value as? MainUiState.Success
            val goalData = state?.rawData?.find { it.goal.id == goalId }
            val maxOrder = goalData?.tasks?.maxOfOrNull { it.orderIndex } ?: -1

            val id = dao.upsertTask(Task(title = "", goalId = goalId, description = "", orderIndex = maxOrder + 1)).toInt()
            _expandedGoalIds.update { it + goalId }
            startEditing(id, isGoal = false)
        }
    }

    fun startEditing(id: Int, isGoal: Boolean) {
        _editingId.value = if (isGoal) "goal_$id" else "task_$id"
        _selectedActionItem.value = null
    }

    fun stopEditing() {
        _editingId.value = null
    }

    fun selectActionItem(target: ActionTarget?) {
        _selectedActionItem.value = target
    }

    fun toggleGoalExpanded(goalId: Int) {
        _expandedGoalIds.update { if (it.contains(goalId)) it - goalId else it + goalId }
    }

    fun showTaskDetails(task: Task?) {
        _selectedTaskForDetails.value = task
    }

    fun updateGoalTitle(goal: Goal, title: String) = viewModelScope.launch {
        dao.upsertGoal(goal.copy(title = title))
    }

    fun updateTaskTitle(task: Task, title: String) = viewModelScope.launch {
        dao.upsertTask(task.copy(title = title))
    }

    fun updateTaskDescription(task: Task, desc: String) = viewModelScope.launch {
        dao.upsertTask(task.copy(description = desc))
    }

    fun toggleStatus(target: ActionTarget) = viewModelScope.launch {
        when (target) {
            is ActionTarget.GoalTarget -> dao.upsertGoal(target.goal.copy(status = if (target.goal.status == TaskStatus.TODO) TaskStatus.DONE else TaskStatus.TODO))
            is ActionTarget.TaskTarget -> dao.upsertTask(target.task.copy(status = if (target.task.status == TaskStatus.TODO) TaskStatus.DONE else TaskStatus.TODO))
        }
    }

    fun cyclePriority() {
        val current = _selectedActionItem.value ?: return
        prioritySaveJob?.cancel()
        val updated = when (current) {
            is ActionTarget.GoalTarget -> current.copy(goal = current.goal.copy(priority = (current.goal.priority + 1) % 3))
            is ActionTarget.TaskTarget -> current.copy(task = current.task.copy(priority = (current.task.priority + 1) % 3))
        }
        _selectedActionItem.value = updated
        prioritySaveJob = viewModelScope.launch {
            delay(1000)
            when (val target = _selectedActionItem.value) {
                is ActionTarget.GoalTarget -> dao.upsertGoal(target.goal)
                is ActionTarget.TaskTarget -> dao.upsertTask(target.task)
                null -> {}
            }
        }
    }

    fun deleteCurrentTarget() = viewModelScope.launch {
        when (val current = _selectedActionItem.value) {
            is ActionTarget.GoalTarget -> dao.deleteGoal(current.goal)
            is ActionTarget.TaskTarget -> dao.deleteTask(current.task)
            null -> {}
        }
        _selectedActionItem.value = null
    }

    sealed class ActionTarget {
        data class GoalTarget(val goal: Goal) : ActionTarget()
        data class TaskTarget(val task: Task) : ActionTarget()
        val id: Int get() = when(this) { is GoalTarget -> goal.id; is TaskTarget -> task.id }
    }
}

sealed class GoalListItem {
    data class GoalHeader(val goal: Goal, val isExpanded: Boolean) : GoalListItem()
    data class TaskItem(val task: Task) : GoalListItem()
}

package com.skrpld.goalion.ui.screens.main

import androidx.compose.animation.*
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.skrpld.goalion.ui.components.main.TaskDetailsDialog
import org.koin.androidx.compose.koinViewModel

@Composable
fun MainScreen(
    viewModel: MainViewModel = koinViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val selectedActionItem by viewModel.selectedActionItem.collectAsStateWithLifecycle()
    val selectedTaskForDetails by viewModel.selectedTaskForDetails.collectAsStateWithLifecycle()
    val editingId by viewModel.editingId.collectAsStateWithLifecycle()

    Scaffold(
        floatingActionButton = {
            ActionFabMenu(
                selectedTarget = selectedActionItem,
                onAddGoal = {
                    when (val state = uiState) {
                        is MainViewModel.MainUiState.Success -> viewModel.addGoal(state.profileId)
                        is MainViewModel.MainUiState.Empty -> viewModel.addGoal(state.profileId)
                        else -> {}
                    }
                },
                onDelete = { viewModel.deleteCurrentTarget() },
                onEdit = {
                    selectedActionItem?.let { target ->
                        val isGoal = target is MainViewModel.ActionTarget.GoalTarget
                        viewModel.startEditing(target.id, isGoal)
                    }
                },
                onPriority = { viewModel.cyclePriority() }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .clickable(
                    interactionSource = remember { MutableInteractionSource() },
                    indication = null,
                    onClick = { viewModel.selectActionItem(null) }
                )
        ) {
            when (val state = uiState) {
                is MainViewModel.MainUiState.Loading -> CircularProgressIndicator(Modifier.align(Alignment.Center))
                is MainViewModel.MainUiState.Empty -> {
                    Text("List is empty", Modifier.align(Alignment.Center))
                }
                is MainViewModel.MainUiState.Success -> {
                    GoalsList(
                        items = state.items,
                        editingId = editingId,
                        selectedActionItem = selectedActionItem,
                        onGoalToggle = { viewModel.toggleGoalExpanded(it) },
                        onGoalLongClick = { viewModel.selectActionItem(MainViewModel.ActionTarget.GoalTarget(it)) },
                        onGoalDoubleClick = { viewModel.toggleStatus(MainViewModel.ActionTarget.GoalTarget(it)) },
                        onTaskClick = { viewModel.showTaskDetails(it) },
                        onTaskLongClick = { viewModel.selectActionItem(MainViewModel.ActionTarget.TaskTarget(it)) },
                        onTaskDoubleClick = { viewModel.toggleStatus(MainViewModel.ActionTarget.TaskTarget(it)) },
                        onAddTask = { goalId -> viewModel.addTask(goalId) },
                        onTitleChange = { id, title, isGoal ->
                            if (isGoal) {
                                (state.items.find { it is GoalListItem.GoalHeader && it.goal.id == id } as? GoalListItem.GoalHeader)?.let {
                                    viewModel.updateGoalTitle(it.goal, title)
                                }
                            } else {
                                (state.items.find { it is GoalListItem.TaskItem && it.task.id == id } as? GoalListItem.TaskItem)?.let {
                                    viewModel.updateTaskTitle(it.task, title)
                                }
                            }
                        },
                        onEditDone = { viewModel.stopEditing() },
                        onMoveGoal = viewModel::moveGoal,
                        onMoveTask = viewModel::moveTask
                    )
                }
            }
        }

        selectedTaskForDetails?.let { task ->
            TaskDetailsDialog(
                task = task,
                onDismiss = { viewModel.showTaskDetails(null) },
                onSaveDescription = { viewModel.updateTaskDescription(task, it) }
            )
        }
    }
}

@Composable
fun ActionFabMenu(
    selectedTarget: MainViewModel.ActionTarget?,
    onAddGoal: () -> Unit,
    onDelete: () -> Unit,
    onEdit: () -> Unit,
    onPriority: () -> Unit
) {
    Column(
        horizontalAlignment = Alignment.End,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        AnimatedVisibility(
            visible = selectedTarget != null,
            enter = expandVertically() + fadeIn(),
            exit = shrinkVertically() + fadeOut()
        ) {
            Column(
                verticalArrangement = Arrangement.spacedBy(4.dp),
                horizontalAlignment = Alignment.End
            ) {
                SmallFloatingActionButton(onClick = onDelete, containerColor = MaterialTheme.colorScheme.errorContainer) {
                    Icon(Icons.Default.Delete, contentDescription = null)
                }
                SmallFloatingActionButton(onClick = onEdit) {
                    Icon(Icons.Default.Edit, contentDescription = null)
                }
                SmallFloatingActionButton(onClick = onPriority) {
                    Icon(Icons.Default.PriorityHigh, contentDescription = null)
                }
            }
        }
        FloatingActionButton(onClick = onAddGoal) {
            Icon(Icons.Default.Add, contentDescription = null)
        }
    }
}

package com.skrpld.goalion.ui.screens.main

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.skrpld.goalion.data.models.Goal
import com.skrpld.goalion.data.models.Task
import com.skrpld.goalion.ui.components.main.GoalCard

@Composable
fun GoalsList(
    items: List<GoalListItem>,
    editingId: String?,
    selectedActionItem: MainViewModel.ActionTarget?,
    onGoalToggle: (Int) -> Unit,
    onGoalLongClick: (Goal) -> Unit,
    onGoalDoubleClick: (Goal) -> Unit,
    onTaskClick: (Task) -> Unit,
    onTaskLongClick: (Task) -> Unit,
    onTaskDoubleClick: (Task) -> Unit,
    onAddTask: (Int) -> Unit,
    onTitleChange: (Int, String, Boolean) -> Unit,
    onEditDone: () -> Unit,
    onMoveGoal: (Int, Int) -> Unit,
    onMoveTask: (Int, Int, Int) -> Unit
) {
    val groupedData = remember(items) {
        val result = mutableListOf<Triple<GoalListItem.GoalHeader, List<Task>, Int>>()
        var currentGoalHeader: GoalListItem.GoalHeader? = null
        var currentTasks = mutableListOf<Task>()
        var goalIndex = 0

        items.forEach { item ->
            when (item) {
                is GoalListItem.GoalHeader -> {
                    if (currentGoalHeader != null) {
                        result.add(Triple(currentGoalHeader!!, currentTasks.toList(), goalIndex++))
                    }
                    currentGoalHeader = item
                    currentTasks = mutableListOf()
                }
                is GoalListItem.TaskItem -> {
                    currentTasks.add(item.task)
                }
            }
        }
        currentGoalHeader?.let { result.add(Triple(it, currentTasks.toList(), goalIndex)) }
        result
    }

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        itemsIndexed(
            items = groupedData,
            key = { _, triple -> "goal_${triple.first.goal.id}" }
        ) { index, (header, tasks, _) ->
            GoalCard(
                goal = header.goal,
                tasks = tasks,
                isExpanded = header.isExpanded,
                isEditing = editingId == "goal_${header.goal.id}",
                selectedTarget = selectedActionItem,
                editingTaskId = editingId,
                onToggle = { onGoalToggle(header.goal.id) },
                onLongClick = { onGoalLongClick(header.goal) },
                onDoubleClick = { onGoalDoubleClick(header.goal) },
                onTaskClick = onTaskClick,
                onTaskLongClick = onTaskLongClick,
                onTaskDoubleClick = onTaskDoubleClick,
                onAddSubTask = { onAddTask(header.goal.id) },
                onTitleChange = { onTitleChange(header.goal.id, it, true) },
                onTaskTitleChange = { id, title -> onTitleChange(id, title, false) },
                onEditDone = onEditDone,
                onMoveTask = { from, to -> onMoveTask(header.goal.id, from, to) },
                modifier = Modifier.animateItem()
            )
        }
    }
}

package com.skrpld.goalion.ui.components.main

import androidx.compose.animation.*
import androidx.compose.animation.core.spring
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.border
import androidx.compose.foundation.combinedClickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.skrpld.goalion.data.database.TaskStatus
import com.skrpld.goalion.data.models.Goal
import com.skrpld.goalion.data.models.Task
import com.skrpld.goalion.ui.screens.main.MainViewModel

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun GoalCard(
    goal: Goal,
    tasks: List<Task>,
    isExpanded: Boolean,
    isEditing: Boolean,
    selectedTarget: MainViewModel.ActionTarget?,
    editingTaskId: String?,
    onToggle: () -> Unit,
    onLongClick: () -> Unit,
    onDoubleClick: () -> Unit,
    onTaskClick: (Task) -> Unit,
    onTaskLongClick: (Task) -> Unit,
    onTaskDoubleClick: (Task) -> Unit,
    onAddSubTask: () -> Unit,
    onTitleChange: (String) -> Unit,
    onTaskTitleChange: (Int, String) -> Unit,
    onEditDone: () -> Unit,
    onMoveTask: (Int, Int) -> Unit,
    modifier: Modifier = Modifier
) {
    val isGoalSelected = selectedTarget is MainViewModel.ActionTarget.GoalTarget && selectedTarget.goal.id == goal.id

    val priorityColor = when(goal.priority) {
        0 -> MaterialTheme.colorScheme.error
        1 -> MaterialTheme.colorScheme.tertiary
        else -> MaterialTheme.colorScheme.primary
    }

    ElevatedCard(
        modifier = modifier
            .fillMaxWidth()
            .animateContentSize(animationSpec = spring(dampingRatio = 0.8f, stiffness = 400f))
            .border(
                width = if (isGoalSelected) 2.dp else 0.dp,
                color = if (isGoalSelected) MaterialTheme.colorScheme.primary else Color.Transparent,
                shape = MaterialTheme.shapes.medium
            ),
        colors = CardDefaults.elevatedCardColors(
            containerColor = MaterialTheme.colorScheme.surface
        )
    ) {
        Column {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .combinedClickable(
                        onClick = onToggle,
                        onLongClick = onLongClick,
                        onDoubleClick = onDoubleClick
                    )
                    .drawBehind {
                        drawRect(color = priorityColor, size = size.copy(width = 6.dp.toPx()))
                    }
                    .padding(16.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                EditableTitle(
                    title = goal.title,
                    isEditing = isEditing,
                    isDone = goal.status == TaskStatus.DONE,
                    onTitleChange = onTitleChange,
                    onEditDone = onEditDone,
                    textStyle = MaterialTheme.typography.titleMedium,
                    placeholder = "Goal title..."
                )
            }

            AnimatedVisibility(
                visible = isExpanded,
                enter = fadeIn() + expandVertically(),
                exit = fadeOut() + shrinkVertically()
            ) {
                Column(
                    modifier = Modifier.padding(start = 16.dp, end = 16.dp, bottom = 16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    tasks.forEach { task ->
                        val isTaskSelected = selectedTarget is MainViewModel.ActionTarget.TaskTarget && selectedTarget.task.id == task.id
                        TaskCard(
                            task = task,
                            isEditing = editingTaskId == "task_${task.id}",
                            isSelected = isTaskSelected,
                            onTitleChange = { onTaskTitleChange(task.id, it) },
                            onEditDone = onEditDone,
                            onClick = { onTaskClick(task) },
                            onLongClick = { onTaskLongClick(task) },
                            onDoubleClick = { onTaskDoubleClick(task) },
                            modifier = Modifier
                        )
                    }

                    OutlinedButton(
                        onClick = onAddSubTask,
                        modifier = Modifier.fillMaxWidth(),
                        shape = MaterialTheme.shapes.medium,
                        contentPadding = PaddingValues(8.dp)
                    ) {
                        Icon(Icons.Default.Add, contentDescription = null, modifier = Modifier.size(18.dp))
                        Spacer(Modifier.width(8.dp))
                        Text("Add task")
                    }
                }
            }
        }
    }
}

package com.skrpld.goalion.ui.components.main

import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.border
import androidx.compose.foundation.combinedClickable
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.skrpld.goalion.data.database.TaskStatus
import com.skrpld.goalion.data.models.Task

@OptIn(ExperimentalFoundationApi::class)
@Composable
fun TaskCard(
    task: Task,
    isEditing: Boolean,
    isSelected: Boolean,
    onTitleChange: (String) -> Unit,
    onEditDone: () -> Unit,
    onClick: () -> Unit,
    onLongClick: () -> Unit,
    onDoubleClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val priorityColor = when(task.priority) {
        0 -> MaterialTheme.colorScheme.error
        1 -> MaterialTheme.colorScheme.tertiary
        else -> MaterialTheme.colorScheme.primary
    }

    Card(
        modifier = modifier
            .fillMaxWidth()
            .border(
                width = if (isSelected) 2.dp else 0.dp,
                color = if (isSelected) MaterialTheme.colorScheme.primary else Color.Transparent,
                shape = MaterialTheme.shapes.small
            ),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)
        )
    ) {
        Row(
            modifier = Modifier
                .combinedClickable(
                    onClick = onClick,
                    onLongClick = onLongClick,
                    onDoubleClick = onDoubleClick
                )
                .drawBehind {
                    drawRect(color = priorityColor, size = size.copy(width = 4.dp.toPx()))
                }
                .padding(12.dp)
        ) {
            EditableTitle(
                title = task.title,
                isEditing = isEditing,
                isDone = task.status == TaskStatus.DONE,
                onTitleChange = onTitleChange,
                onEditDone = onEditDone,
                textStyle = MaterialTheme.typography.bodyMedium,
                placeholder = "Task title..."
            )
        }
    }
}

package com.skrpld.goalion.ui.components.main

import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.text.BasicTextField
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.text.TextRange
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.TextFieldValue
import androidx.compose.ui.text.style.TextDecoration

@Composable
fun EditableTitle(
    title: String,
    isEditing: Boolean,
    isDone: Boolean,
    onTitleChange: (String) -> Unit,
    onEditDone: () -> Unit,
    textStyle: TextStyle,
    placeholder: String
) {
    val focusRequester = remember { FocusRequester() }
    var textFieldValueState by remember { mutableStateOf(TextFieldValue(title)) }

    LaunchedEffect(isEditing) {
        if (isEditing) {
            textFieldValueState = TextFieldValue(text = title, selection = TextRange(title.length))
            focusRequester.requestFocus()
        }
    }

    if (isEditing) {
        BasicTextField(
            value = textFieldValueState,
            onValueChange = {
                textFieldValueState = it
                onTitleChange(it.text)
            },
            textStyle = textStyle.copy(color = MaterialTheme.colorScheme.onSurface),
            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done),
            keyboardActions = KeyboardActions(onDone = { onEditDone() }),
            modifier = Modifier
                .focusRequester(focusRequester)
                .fillMaxWidth(),
            cursorBrush = SolidColor(MaterialTheme.colorScheme.primary)
        )
    } else {
        Text(
            text = title.ifEmpty { placeholder },
            style = textStyle.copy(
                textDecoration = if (isDone) TextDecoration.LineThrough else null,
                color = if (isDone) MaterialTheme.colorScheme.outline else MaterialTheme.colorScheme.onSurface
            ),
            modifier = Modifier.fillMaxWidth()
        )
    }
}